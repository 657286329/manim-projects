Hello,大家好
这一期视频我来讲解一下快速傅里叶变换
是的 我用回了自己的声音
由于这一期视频的内容比较多 而且并不适合全部观看
所以我选择了将这期视频做成了互动视频
以便观众根据需要选择观看的方式
观看本视频最短路径需要   min 最长需要   min
由于这是我第一次做这样的视频 经验还不够
所以看完后不妨在评论区投个票留下些反馈吧

那么首先 我们来看一下学习快速傅里叶变换算法需要哪些前置知识
FFT的核心算法是基于复数和单位根的
所以 我们当然需要先了解复数的相关运算法则
而且需要了解单位根的一些独特性质
来学习快速傅里叶变换背后的原理
最后 在算法竞赛中 FFT的最普遍应用是求多项式乘法 或者说卷积
所以 如果需要学习用FFT求多项式乘法的话 也需要有多项式的相关知识
那么现在 做出你的选择吧


形如z=a+bi的数被称为复数
其中a、b为实数 i为根号-1 称为虚数单位
就如同1为实数单位一样
在复数中 a被称为实部 b被称为虚部
复数的加法运算也十分简单
只要将i看做一个字母 对原式运用分配律结合律 就能得到最后的法则
即结果的实部为两加数实部的和
结果的虚部为两加数虚部的和
如果是进行减法的话 只需将黄色符号变成减号即可
对于两复数的乘法也是同理 将i看作字母
将原式拆开 再根据i等于根号-1 i方等于-1 进行化简就能得到结果
对于除法 FFT中并没有涉及 但这里还是简要地给出
其主要思想是分数上下同乘分母的共轭复数 即c-di
使分母变为实数 再进行化简 这里直接给出公式
对于复数 还有一个很重要的定理 即欧拉定理
它可以将一个负数表示成e指数的形式 方便运算
所以一个负数也可以写成 r乘e的iθ次方
其中r为它的模 θ为它的辐角

任意一个复数a+bi对应了复平面上的一个点（a，b）
其横坐标为实部 纵坐标为虚部
通过复平面我们可以更好地理解复数
前面我们所说的模 即为它在复平面上对应的点到原点的距离
辐角即为它在复平面上对应的点到原点连线与x轴的夹角
知道了复数的运算法则 我们就能用代码来实现它了


FFT的核心是用单位根的某些独特性质来快速实现的
单位根 即为方程w^n=1在复数范围内的n个根
对于单位根 使用复平面会更好理解
我们知道 每个复数都可以表示为模乘以e的(i辐角)次方
所以两个复数相乘的结果即为 两复数模相乘再乘以e的(i辐角的和)次方
因为单位根的n次方为1 所以单位根的模一定为1
所以单位根乘其自身就相当于辐角加一倍
由于每个单位根的n次方都落在复平面上(1,0)这个点
所以每个单位根的辐角的n倍都是2π的倍数
那我们就可以轻松在复平面上找到这些点
而我们可以发现 单位根都均匀地落在单位圆上
每个单位根都可以看成这个单位根的幂
所以我们将这个根称为主n次单位根 记为w_n
根据欧拉定理 我们就可以将其写成实部加i乘虚部的形式

下面我们来探寻一下单位根的三个重要引理
首先是消去引理 即w_{dn}^{dk}=w_n^k
我们用定义可以轻松地推出这个结论
在复平面上 我们可以更简单地理解这个结论
在图上可以看出 主dn次单位根的dk次幂
恰好与主n次单位根的k次幂相重合
第二个是折半引理 也是FFT的核心
同理 我们先用计算来推出这个结论
然后在复平面上 我们以8次单位根为例
将主8次单位根平方 即辐角加倍
再将主8次单位根的(1+4)次幂平方
也可以发现 这两个点重合了
同时 这两个点也和主4次单位根重合
这也就用复平面解释了这个引理
第三个是求和引理 将在逆FFT中用到
我们将任意一个单位根求其几何级数
根据等比数列求和公式 就可以计算出
这个值恒等于0


在算法竞赛中FFT经常用来处理多项式乘法的内容
那么我们现在来了解一下关于多项式的前置知识
首先多项式是指由未知数和系数通过有限次加减法
乘法以及自然数幂次的乘方运算得到的代数表达式
如下F(x)就是一个n次多项式
在算法竞赛中 经常处理的就是这样的一元多项式
对于这个多项式 我们还可以用Σ来简单表示
其中多项式的次数 就是最高次的次数
记为degree(F)=n
多项式的次数界 指任何一个严格大于多项式次数的整数
由于FFT只能处理2的幂次 所以要引入次数界的概念来将多项式扩展次数
下面我们来看多项式的运算法则
首先多项式的加法
现有两个多项式A(x)和B(x) 将其相加
可以将AB中x的次数相等的两项加在一起
最后就得到了结果的多项式C(x)
当然 我们可以用∑来简写
其中的系数c_i 即为对应相等x次数的项的系数之和a_i加b_i

再来看一下多项式的乘法
我们先以一个具体的例子为例
将这两个多项式相乘 可以用第二个多项式的每一项
乘以第一个多项式 得到三个多项式
再对三个多项式进行加法运算 得到最终的结果
通过结果可以发现 结果的次数为两多项式次数的和
再推广到两同次多项式相乘的情况 给出两个n次多项式AB求其乘积C
根据刚刚的结论 可以知道结果的次数为2n
它的系数根据前面的计算方法可以稍加演算推导出来
而这个系数向量c又被称为向量ab的卷积
再一般的情况为了计算简便
可以将两个多项式的次数用添加0系数的方法升至次数界中的同一次数n
那么其乘积也是次数为2n的多项式

多项式有两种表示方法
第一种是系数表示 也是平时最常用最直观的表示方法
它将一个多项式表示成由其系数构成的向量的形式
用系数表示进行运算时 
加法直接将对应项相加 时间复杂度O(n)
乘法则计算两多项式系数向量的卷积 复杂度O(n^2)
已知系数 给出一个x值并求A(x)的过程叫求值
可以直接使用霍纳法则即秦九韶算法 复杂度O(n)
第二种表示方法是点值表示 即用至少n个多项式上的点来表示
使用点值表示进行运算时 一般要保证两多项式在同一位置取值 即x_i相同
进行加法运算 直接依次将两点纵坐标相加 复杂度O(n)
进行乘法运算 只需将两点纵坐标相乘
复杂度O(n) 远好于系数表式的O(n^2)
已知点值 给出一个x值并求A(x)的过程叫插值
一般的 我们可以根据拉格朗日插值公式来进行计算 复杂度O(n^2)


那么现在我们步入正题 什么是快速傅里叶变换
首先我们要了解离散傅里叶变换(discrete fourier transform)
离散傅里叶变换是对于一个向量进行的变换
可以将这个向量看成一个n-1次多项式
并在每个单位根处求值 得出向量y 就是离散傅里叶变换后的结果
记为y=DFT_n(a) 也可以记为y=花体F(a)
直接使用霍纳法则求值的话 一次求值复杂度O(n)
求n个值的总复杂度就是O(n^2)
而快速傅里叶变换(Fast Fourier Transform)
是一种快速进行离散傅里叶变换的方法
它可以通过单位根的性质 将n次求值的复杂度降为O(nlog n)

首先对于这个n-1次多项式 它的系数向量为a
我们将其分为偶数项和奇数项两个向量 记为a^[0]和a^[1]
它们对应的两个多项式为A^[0]和A^[1]
现在将x代入 写出的A(x)的表达式是这样的
A^[0](x)和A^[1](x)的表达式是这样的
我们来想想办法把这三个表达式关联起来
把后两个表达式的自变量x换成x^2
我们会发现第二个表达式的项在第一个表达式中全部出现
而第三个表达式中的每一项都差了一个x
所以我们在它的前面乘以一个x
最后我们可以发现 A(x)=A^0(x^2)+xA^1(x^2)
这是我们就将原问题求A(x)在每个单位根上的值转化为
求次数界为n/2的两个多项式A^0(x)和A^1(x)在每个单位根平方上的值 再合并
我们代入两个具体单位根来看一看情况

根据我们之前提过的折半引理和消去引理 可以写出如下表达式
所以w_n^k方和w_n^{k+n/2}方均可以写成w_{n/2}^k
而A^0(x)和A^1(x)恰好均为次数界为n/2的多项式
所以问题又转化为了求
次数界为n/2的多项式A^0和A^1在各个n/2次单位根上的值
这两个问题和原问题的描述类似 只是原问题的次数界为n
所以 这两个问题是范围缩小一半的两个子问题
我们可以用同样方式求解这两个子问题（也就是递归解决）
再根据折半引理 就可以快速地合并结果
根据这个思想 我们可以写出运行时间T(n)的递归式
再根据主定理或者递归树 均可以推算出这个算法的时间复杂度为O(nlog n)
比代入公式求解的O(n^2)快了很多很多